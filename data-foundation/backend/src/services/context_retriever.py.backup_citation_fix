#!/usr/bin/env python3
"""
Context Retriever Service
Provides context data for different environmental and operational intents.
This service integrates with the Executive Dashboard Service to provide consistent progress data.
"""

import logging
import json
from typing import Dict, Any, Optional, List
from datetime import datetime
from dotenv import load_dotenv


class ContextRetriever:
    """
    Service for retrieving context data based on user intents.
    Provides hardcoded progress metrics for CO2 reduction goals.
    """

    def __init__(self):
        """Initialize the Context Retriever."""
        load_dotenv()
        self.logger = logging.getLogger(__name__)
        self.logger.info("ContextRetriever initialized successfully")

    def get_co2_goals_context(self, site: Optional[str] = None, **kwargs) -> Dict[str, Any]:
        """
        Get context data for CO2 reduction goals and progress.
        This method provides hardcoded progress data for Algonquin and Houston sites.
        
        Args:
            site: Optional site filter (e.g., 'algonquin', 'houston')
            **kwargs: Additional parameters (ignored)
        
        Returns:
            Dictionary containing formatted context for CO2 goals with progress data
        """
        self.logger.info(f"Retrieving CO2 goals context for site: {site}")
        
        # Hardcoded progress data for each site
        site_progress_data = {
            'algonquin': {
                'current_progress': 28.4,
                'target_percentage': 15,
                'baseline_year': 2024,
                'target_year': 2025
            },
            'houston': {
                'current_progress': 22.1,
                'target_percentage': 18,
                'baseline_year': 2024,
                'target_year': 2025
            }
        }
        
        if site:
            site_key = site.lower()
            if site_key in site_progress_data:
                data = site_progress_data[site_key]
                current_progress = data['current_progress']
                target_percentage = data['target_percentage']
                baseline_year = data['baseline_year']
                target_year = data['target_year']
                
                # Create direct context statement as requested
                context = {
                    'intent_type': 'co2_goals',
                    'summary': f"{site.title()} is currently at {current_progress}% progress toward its {target_percentage}% CO2 reduction goal by {target_year}, baseline year {baseline_year}",
                    'data': {
                        'site': site_key,
                        'current_progress_percentage': current_progress,
                        'target_reduction_percentage': target_percentage,
                        'baseline_year': baseline_year,
                        'target_year': target_year,
                        'status': 'tracking_on_schedule',
                        'confidence_level': 'high'
                    },
                    'metadata': {
                        'data_source': 'hardcoded_operational_data',
                        'last_updated': datetime.now().isoformat(),
                        'data_availability': 'complete',
                        'tracking_method': 'operational_metrics'
                    }
                }
                
                self.logger.info(f"Successfully retrieved CO2 goals context for {site}: {current_progress}% progress")
                return context
            else:
                # Site not tracked
                context = {
                    'intent_type': 'co2_goals',
                    'summary': f"CO2 reduction goal tracking is not currently available for the {site} site. Please check with the environmental team for the latest progress updates.",
                    'data': {},
                    'metadata': {
                        'data_source': 'hardcoded_operational_data',
                        'status': 'site_not_tracked'
                    }
                }
                
                self.logger.warning(f"No CO2 goals data found for site: {site}")
                return context
        else:
            # Return data for all sites
            total_sites = len(site_progress_data)
            
            # Create site summaries
            site_summaries = []
            for site_name, site_data in site_progress_data.items():
                progress = site_data['current_progress']
                target = site_data['target_percentage']
                baseline_year = site_data['baseline_year']
                target_year = site_data['target_year']
                site_summaries.append(f"{site_name.title()} site is at {progress}% progress toward its {target}% CO2 reduction goal by {target_year}")
            
            context = {
                'intent_type': 'co2_goals',
                'summary': f"CO2 reduction progress is being actively tracked across {total_sites} operational sites. " + ". ".join(site_summaries) + ". All data is current and sourced from operational monitoring systems.",
                'data': {
                    'sites': site_progress_data,
                    'total_sites': total_sites,
                    'overall_status': 'active_tracking'
                },
                'metadata': {
                    'data_source': 'hardcoded_operational_data',
                    'data_points': total_sites,
                    'last_updated': datetime.now().isoformat(),
                    'confidence_level': 'high'
                }
            }
            
            self.logger.info(f"Successfully retrieved CO2 goals context for all {total_sites} sites")
            return context

    def get_risk_assessment_context(self, site: Optional[str] = None, 
                                  start_date: Optional[str] = None,
                                  end_date: Optional[str] = None, **kwargs) -> Dict[str, Any]:
        """
        Get context data for risk assessment.
        This method provides hardcoded risk assessment data for Algonquin and Houston sites.
        
        Args:
            site: Optional site filter (e.g., 'algonquin', 'houston')
            start_date: Optional start date filter (ignored for now)
            end_date: Optional end date filter (ignored for now)
            **kwargs: Additional parameters (ignored)
        
        Returns:
            Dictionary containing formatted context for risk assessment
        """
        self.logger.info(f"Retrieving risk assessment context for site: {site}")
        
        # Hardcoded risk assessment data for each site
        site_risk_data = {
            'algonquin': {
                'overall_risk_level': 'MODERATE',
                'confidence_score': 85.2,
                'total_assessments': 12,
                'risk_categories': {
                    'Air Quality': {'level': 'LOW', 'assessments': 4},
                    'Water Quality': {'level': 'MODERATE', 'assessments': 3},
                    'Waste Management': {'level': 'MODERATE', 'assessments': 2},
                    'Energy Consumption': {'level': 'HIGH', 'assessments': 3}
                },
                'high_priority_risks': [
                    {
                        'category': 'Energy Consumption',
                        'description': 'Projected annual consumption exceeds baseline by 23.4%',
                        'risk_level': 'HIGH',
                        'projected_impact': '$45,600 additional cost',
                        'confidence': 89.1
                    }
                ],
                'risk_factors': [
                    'Equipment efficiency below optimal levels',
                    'Seasonal demand variations',
                    'Legacy equipment scheduled for replacement'
                ],
                'last_assessment': '2024-09-15',
                'next_assessment': '2024-12-15'
            },
            'houston': {
                'overall_risk_level': 'HIGH',
                'confidence_score': 91.7,
                'total_assessments': 15,
                'risk_categories': {
                    'Air Quality': {'level': 'MODERATE', 'assessments': 5},
                    'Water Quality': {'level': 'HIGH', 'assessments': 4},
                    'Waste Management': {'level': 'LOW', 'assessments': 3},
                    'Energy Consumption': {'level': 'HIGH', 'assessments': 3}
                },
                'high_priority_risks': [
                    {
                        'category': 'Water Quality',
                        'description': 'Water consumption patterns indicate potential efficiency issues',
                        'risk_level': 'HIGH',
                        'projected_impact': 'Regulatory compliance concerns',
                        'confidence': 94.3
                    },
                    {
                        'category': 'Energy Consumption',
                        'description': 'Peak demand exceeding grid capacity thresholds',
                        'risk_level': 'HIGH',
                        'projected_impact': '$78,900 additional cost',
                        'confidence': 87.2
                    }
                ],
                'risk_factors': [
                    'High ambient temperatures affecting cooling demand',
                    'Industrial processes requiring continuous operation',
                    'Water recycling system efficiency concerns'
                ],
                'last_assessment': '2024-09-12',
                'next_assessment': '2024-12-12'
            }
        }
        
        if site:
            site_key = site.lower()
            if site_key in site_risk_data:
                data = site_risk_data[site_key]
                overall_risk = data['overall_risk_level']
                confidence = data['confidence_score']
                total_assessments = data['total_assessments']
                
                # Create detailed context statement
                high_risks = [risk for risk in data['high_priority_risks']]
                high_risk_count = len(high_risks)
                
                risk_summary = f"Current overall risk level for {site.title()} is {overall_risk}"
                if high_risk_count > 0:
                    risk_summary += f" with {high_risk_count} high-priority risk(s) identified"
                risk_summary += f". Assessment confidence: {confidence}%."
                
                context = {
                    'intent_type': 'risk_assessment',
                    'summary': risk_summary,
                    'data': {
                        'site': site_key,
                        'overall_risk_level': overall_risk,
                        'confidence_score': confidence,
                        'total_assessments': total_assessments,
                        'risk_categories': data['risk_categories'],
                        'high_priority_risks': data['high_priority_risks'],
                        'risk_factors': data['risk_factors'],
                        'last_assessment_date': data['last_assessment'],
                        'next_assessment_date': data['next_assessment']
                    },
                    'metadata': {
                        'data_source': 'hardcoded_risk_assessment_data',
                        'last_updated': datetime.now().isoformat(),
                        'data_availability': 'complete',
                        'assessment_method': 'environmental_monitoring'
                    }
                }
                
                self.logger.info(f"Successfully retrieved risk assessment context for {site}: {overall_risk} risk level")
                return context
            else:
                # Site not tracked
                context = {
                    'intent_type': 'risk_assessment',
                    'summary': f"Risk assessment data is not currently available for the {site} site. Please check with the environmental team for the latest risk evaluations.",
                    'data': {},
                    'metadata': {
                        'data_source': 'hardcoded_risk_assessment_data',
                        'status': 'site_not_tracked'
                    }
                }
                
                self.logger.warning(f"No risk assessment data found for site: {site}")
                return context
        else:
            # Return data for all sites
            total_sites = len(site_risk_data)
            
            # Create site summaries
            site_summaries = []
            overall_high_risks = 0
            for site_name, site_data in site_risk_data.items():
                risk_level = site_data['overall_risk_level']
                confidence = site_data['confidence_score']
                high_risk_count = len(site_data['high_priority_risks'])
                overall_high_risks += high_risk_count
                
                site_summaries.append(f"{site_name.title()} site has {risk_level} overall risk level with {high_risk_count} high-priority concerns")
            
            context = {
                'intent_type': 'risk_assessment',
                'summary': f"Risk assessment data is available for {total_sites} operational sites with {overall_high_risks} total high-priority risks identified. " + ". ".join(site_summaries) + ". All assessments are current and based on environmental monitoring data.",
                'data': {
                    'sites': site_risk_data,
                    'total_sites': total_sites,
                    'total_high_priority_risks': overall_high_risks,
                    'overall_status': 'active_monitoring'
                },
                'metadata': {
                    'data_source': 'hardcoded_risk_assessment_data',
                    'data_points': total_sites,
                    'last_updated': datetime.now().isoformat(),
                    'confidence_level': 'high'
                }
            }
            
            self.logger.info(f"Successfully retrieved risk assessment context for all {total_sites} sites")
            return context

    
    def _map_site_id(self, site: str) -> str:
        """Map frontend site names to database site_ids"""
        site_mapping = {
            'algonquin': 'algonquin_il',
            'houston': 'houston_tx'
        }
        return site_mapping.get(site.lower(), site.lower())
    def get_recommendations_context(self, site: Optional[str] = None, **kwargs) -> Dict[str, Any]:
        """
        Get context data for recommendations.
        This method retrieves recommendations from Neo4j nodes with the new structure.
        
        Args:
            site: Optional site filter (e.g., 'algonquin', 'houston')
            **kwargs: Additional parameters (ignored)
        
        Returns:
            Dictionary containing formatted context for recommendations
        """
        from neo4j import GraphDatabase
        import os
        
        self.logger.info(f"Retrieving recommendations context for site: {site}")
        
        # Get Neo4j connection details from environment
        neo4j_uri = os.getenv('NEO4J_URI', 'bolt://localhost:7687')
        neo4j_user = os.getenv('NEO4J_USERNAME', 'neo4j')
        neo4j_password = os.getenv('NEO4J_PASSWORD', 'password')
        
        try:
            driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
            
            with driver.session() as session:
                if site:
                    # Query for specific site
                    query = """
                    MATCH (r:Recommendation)
                    WHERE r.site_id = $site
                    RETURN r
                    ORDER BY r.created_date DESC
                    LIMIT 1
                    """
                    mapped_site_id = self._map_site_id(site)
                    result = session.run(query, site=mapped_site_id)
                else:
                    # Query for all sites
                    query = """
                    MATCH (r:Recommendation)
                    RETURN r
                    ORDER BY r.created_date DESC, r.site_id
                    """
                    result = session.run(query)
                
                records = list(result)
                
                if not records:
                    # No recommendations found
                    context = {
                        'intent_type': 'recommendations',
                        'summary': f"No recommendations found{f' for {site}' if site else ''}.",
                        'data': {
                            'recommendations': [],
                            'total_recommendations': 0
                        },
                        'metadata': {
                            'data_source': 'neo4j_recommendations',
                            'last_updated': datetime.now().isoformat(),
                            'site_filter': site if site else 'all_sites'
                        }
                    }
                    
                    self.logger.warning(f"No recommendations found{f' for site: {site}' if site else ''}")
                    return context
                
                all_recommendations = []
                sites_processed = set()
                total_recs = 0
                
                for record in records:
                    node = record['r']
                    site_id = node.get('site_id', 'unknown')
                    sites_processed.add(site_id)
                    
                    # Parse the JSON recommendations field
                    recommendations_json = node.get('recommendations', '[]')
                    try:
                        if isinstance(recommendations_json, str):
                            recommendations_list = json.loads(recommendations_json)
                        else:
                            recommendations_list = recommendations_json
                    except json.JSONDecodeError as e:
                        self.logger.error(f"Failed to parse recommendations JSON for site {site_id}: {e}")
                        recommendations_list = []
                    
                    # Process each recommendation in the array
                    for rec in recommendations_list:
                        if isinstance(rec, dict):
                            # Add site context to each recommendation
                            processed_rec = {
                                'site_id': site_id,
                                'title': rec.get('title', 'Untitled Recommendation'),
                                'description': rec.get('description', 'No description available'),
                                'category': rec.get('category', 'General'),
                                'priority': rec.get('priority', 'Medium'),
                                'status': rec.get('status', 'Open'),
                                'impact': rec.get('impact', 'Unknown'),
                                'effort': rec.get('effort', 'Unknown'),
                                'created_date': node.get('created_date', ''),
                                'type': node.get('type', ''),
                                'version': node.get('version', ''),
                                'recommendation_id': rec.get('id', f"{site_id}_{len(all_recommendations)}")
                            }
                            all_recommendations.append(processed_rec)
                            total_recs += 1
                
                # Create summary based on site filter
                if site:
                    site_recs = [r for r in all_recommendations if r['site_id'].lower() == mapped_site_id.lower()]
                    rec_count = len(site_recs)
                    summary = f"Found {rec_count} recommendation(s) for {site.title()} site."
                    if rec_count > 0:
                        categories = list(set([r['category'] for r in site_recs]))
                        summary += f" Categories include: {', '.join(categories)}."
                    
                    context_data = {
                        'recommendations': site_recs,
                        'total_recommendations': rec_count,
                        'site': site.lower(),
                        'categories': categories if rec_count > 0 else []
                    }
                else:
                    summary = f"Found {total_recs} recommendation(s) across {len(sites_processed)} site(s)."
                    if total_recs > 0:
                        categories = list(set([r['category'] for r in all_recommendations]))
                        summary += f" Categories include: {', '.join(categories)}."
                    
                    context_data = {
                        'recommendations': all_recommendations,
                        'total_recommendations': total_recs,
                        'sites': list(sites_processed),
                        'categories': categories if total_recs > 0 else []
                    }
                
                context = {
                    'intent_type': 'recommendations',
                    'summary': summary,
                    'data': context_data,
                    'metadata': {
                        'data_source': 'neo4j_recommendations',
                        'last_updated': datetime.now().isoformat(),
                        'site_filter': site if site else 'all_sites',
                        'query_successful': True
                    }
                }
                
                self.logger.info(f"Successfully retrieved {total_recs} recommendations{f' for {site}' if site else ''}")
                return context
                
        except Exception as e:
            self.logger.error(f"Error retrieving recommendations from Neo4j: {e}")
            
            # Return error context
            context = {
                'intent_type': 'recommendations',
                'summary': f"Unable to retrieve recommendations{f' for {site}' if site else ''} due to database connection issues.",
                'data': {
                    'recommendations': [],
                    'total_recommendations': 0,
                    'error': str(e)
                },
                'metadata': {
                    'data_source': 'neo4j_recommendations',
                    'last_updated': datetime.now().isoformat(),
                    'site_filter': site if site else 'all_sites',
                    'query_successful': False,
                    'error': str(e)
                }
            }
            
            return context
        
        finally:
            try:
                driver.close()
            except:
                pass

    def get_context_for_intent(self, intent: str, site: Optional[str] = None, 
                             start_date: Optional[str] = None, end_date: Optional[str] = None,
                             **kwargs) -> Dict[str, Any]:
        """
        Main method to retrieve context based on intent type.
        
        Args:
            intent: The type of context to retrieve (e.g., 'co2_goals', 'electricity_consumption')
            site: Optional site filter
            start_date: Optional start date filter
            end_date: Optional end date filter
            **kwargs: Additional parameters
        
        Returns:
            Dictionary containing context data formatted for LLM
        """
        self.logger.info(f"Retrieving context for intent: {intent}")
        
        if intent == 'co2_goals' or intent == 'co2_reduction' or intent == 'emissions_goals':
            return self.get_co2_goals_context(site=site, start_date=start_date, end_date=end_date, **kwargs)
        
        elif intent == 'environmental_compliance':
            return self._get_environmental_compliance_context(site, start_date, end_date, **kwargs)
        
        elif intent == 'water_consumption':
            return self._get_water_consumption_context(site, start_date, end_date, **kwargs)
        
        elif intent == 'waste_generation':
            return self._get_waste_generation_context(site, start_date, end_date, **kwargs)
        
        elif intent == 'electricity_consumption':
            return self._get_electricity_consumption_context(site, start_date, end_date, **kwargs)
        
        elif intent == 'safety_incidents':
            return self._get_safety_incidents_context(site, start_date, end_date, **kwargs)
        
        elif intent == 'operational_metrics':
            return self._get_operational_metrics_context(site, start_date, end_date, **kwargs)
        
        elif intent == 'risk_assessment':
            return self.get_risk_assessment_context(site=site, start_date=start_date, end_date=end_date, **kwargs)
        
        elif intent == 'recommendations' or intent == 'recommendation':
            return self.get_recommendations_context(site=site, **kwargs)
        
        else:
            return {
                'intent_type': intent,
                'summary': f"Context retrieval for intent '{intent}' not yet implemented.",
                'data': {},
                'metadata': {
                    'status': 'not_implemented',
                    'intent': intent
                }
            }

    def _get_environmental_compliance_context(self, site: Optional[str], start_date: Optional[str], 
                                            end_date: Optional[str], **kwargs) -> Dict[str, Any]:
        """Stub implementation for environmental compliance context."""
        self.logger.info("Retrieving context for intent: environmental_compliance")
        return {
            'intent_type': 'environmental_compliance',
            'summary': 'Environmental compliance context retrieval not yet implemented. This is a placeholder.',
            'data': {},
            'metadata': {'status': 'stub_implementation'}
        }

    def _get_water_consumption_context(self, site: Optional[str], start_date: Optional[str], 
                                     end_date: Optional[str], **kwargs) -> Dict[str, Any]:
        """Stub implementation for water consumption context."""
        self.logger.info("Retrieving context for intent: water_consumption")
        return {
            'intent_type': 'water_consumption',
            'summary': 'Water consumption context retrieval not yet implemented. This is a placeholder.',
            'data': {},
            'metadata': {'status': 'stub_implementation'}
        }

    def _get_waste_generation_context(self, site: Optional[str], start_date: Optional[str], 
                                    end_date: Optional[str], **kwargs) -> Dict[str, Any]:
        """Stub implementation for waste generation context."""
        self.logger.info("Retrieving context for intent: waste_generation")
        return {
            'intent_type': 'waste_generation',
            'summary': 'Waste generation context retrieval not yet implemented. This is a placeholder.',
            'data': {},
            'metadata': {'status': 'stub_implementation'}
        }

    def _get_electricity_consumption_context(self, site: Optional[str], start_date: Optional[str], 
                                           end_date: Optional[str], **kwargs) -> Dict[str, Any]:
        """Stub implementation for electricity consumption context."""
        self.logger.info("Retrieving context for intent: electricity_consumption")
        return {
            'intent_type': 'electricity_consumption',
            'summary': 'No electricity consumption data found for the specified criteria.',
            'data': {},
            'metadata': {
                'site_filter': site,
                'date_range': f'{start_date} to {end_date}' if start_date and end_date else None,
                'data_points': 0
            }
        }

    def _get_safety_incidents_context(self, site: Optional[str], start_date: Optional[str], 
                                    end_date: Optional[str], **kwargs) -> Dict[str, Any]:
        """Stub implementation for safety incidents context."""
        self.logger.info("Retrieving context for intent: safety_incidents")
        return {
            'intent_type': 'safety_incidents',
            'summary': 'Safety incidents context retrieval not yet implemented. This is a placeholder.',
            'data': {},
            'metadata': {'status': 'stub_implementation'}
        }

    def _get_operational_metrics_context(self, site: Optional[str], start_date: Optional[str], 
                                       end_date: Optional[str], **kwargs) -> Dict[str, Any]:
        """Stub implementation for operational metrics context."""
        self.logger.info("Retrieving context for intent: operational_metrics")
        return {
            'intent_type': 'operational_metrics',
            'summary': 'Operational metrics context retrieval not yet implemented. This is a placeholder.',
            'data': {},
            'metadata': {'status': 'stub_implementation'}
        }

    def format_context_for_llm(self, context_data: Dict[str, Any]) -> str:
        """
        Format context data for LLM consumption.
        
        Args:
            context_data: Context data dictionary
        
        Returns:
            Formatted string for LLM prompt
        """
        intent_type = context_data.get('intent_type', 'unknown').upper()
        summary = context_data.get('summary', 'No summary available')
        metadata = context_data.get('metadata', {})
        trends = context_data.get('trends', [])
        
        formatted = f"CONTEXT TYPE: {intent_type}\n"
        formatted += f"SUMMARY: {summary}\n\n"
        
        if metadata:
            formatted += "METADATA:\n"
            for key, value in metadata.items():
                formatted += f"  {key}: {value}\n"
        
        if trends:
            formatted += "\nTRENDS:\n"
            for trend in trends:
                formatted += f"  - {trend}\n"
        
        return formatted

    def close(self):
        """Close the context retriever and clean up resources."""
        self.logger.info("ContextRetriever connection closed")


# Convenience function for easy access
def get_context_for_electricity(site: str = None, start_date: str = "2024-06-01", end_date: str = "2024-08-31") -> str:
    """
    Convenience function to get electricity consumption context.
    
    Args:
        site: Site name filter
        start_date: Start date for data range
        end_date: End date for data range
    
    Returns:
        Formatted context string
    """
    retriever = ContextRetriever()
    try:
        context = retriever.get_context_for_intent('electricity_consumption', site=site, 
                                                 start_date=start_date, end_date=end_date)
        return retriever.format_context_for_llm(context)
    finally:
        retriever.close()