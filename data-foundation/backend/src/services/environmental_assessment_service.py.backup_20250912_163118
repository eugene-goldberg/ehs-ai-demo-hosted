"""
Environmental Assessment Service

Purpose: Retrieves consumption data from Neo4j and calculates basic facts.

This service ONLY:
- Retrieves historical consumption data from Neo4j
- Calculates basic metrics (sum, average, min, max)
- Returns structured data for dashboard endpoints

This service does NOT:
- Generate risk assessments (handled by Risk Assessment Agent)
- Create recommendations (handled by Risk Assessment Agent)
- Analyze trends (handled by Risk Assessment Agent)
"""

from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
import logging
from statistics import mean, stdev

from src.database.neo4j_client import Neo4jClient

logger = logging.getLogger(__name__)


class EnvironmentalAssessmentService:
    """Service for environmental data retrieval and basic fact calculation."""
    
    def __init__(self, neo4j_client: Neo4jClient):
        """Initialize the service with Neo4j client."""
        self.neo4j_client = neo4j_client

    def get_comprehensive_assessment(
        self, 
        location_filter: Optional[str] = None,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Get comprehensive environmental assessment for all categories.
        
        Args:
            location_filter: Optional location filter
            start_date: Optional start date (YYYY-MM-DD)
            end_date: Optional end date (YYYY-MM-DD)
            
        Returns:
            Dictionary containing assessment data for all categories
        """
        try:
            logger.info(f"Getting comprehensive assessment for location: {location_filter}")
            
            # Get data for each category
            electricity_data = self.assess_electricity_consumption(
                location_filter, start_date, end_date
            )
            water_data = self.assess_water_consumption(
                location_filter, start_date, end_date
            )
            waste_data = self.assess_waste_generation(
                location_filter, start_date, end_date
            )
            
            # Calculate overall metrics
            overall_metrics = self._calculate_overall_metrics(
                electricity_data, water_data, waste_data
            )
            
            return {
                'electricity': electricity_data,
                'water': water_data,
                'waste': waste_data,
                'overall_metrics': overall_metrics,
                'assessment_timestamp': datetime.now().isoformat(),
                'filters': {
                    'location': location_filter,
                    'start_date': start_date,
                    'end_date': end_date
                }
            }
            
        except Exception as e:
            logger.error(f"Error in comprehensive assessment: {e}")
            raise

    def assess_electricity_consumption(
        self,
        location_filter: Optional[str] = None,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Assess electricity consumption data.
        
        Returns:
            Dictionary containing electricity assessment data
        """
        try:
            # FIXED Query - Using Site relationships instead of facility_id and fixed date comparison
            query = """
            MATCH (s:Site)-[:HAS_ELECTRICITY_CONSUMPTION]->(e:ElectricityConsumption)
  WHERE ($location IS NULL OR s.id CONTAINS $location OR s.name CONTAINS $location)
  AND ($start_date IS NULL OR date(e.date) >= date($start_date))
  AND ($end_date IS NULL OR date(e.date) <= date($end_date))
  RETURN s.id as location, s.name as site_name, e.date as date, e.consumption_kwh as consumption,
         e.cost_usd as cost,
         COALESCE(e.source_type, 'Unknown') as source_type,
         COALESCE(e.efficiency_rating, 0.0) as efficiency
  ORDER BY e.date DESC
            """
            
            records = self.neo4j_client.execute_query(
                query,
                parameters={
                    "location": location_filter,
                    "start_date": start_date,
                    "end_date": end_date
                }
            )
            
            if not records:
                return {'error': 'No electricity data found'}
            
            # Process data
            data = [dict(record) for record in records]
            
            # Calculate metrics
            facts = self._calculate_electricity_facts(data)
            # Risks and recommendations come from Neo4j (generated by Risk Assessment Agent)
            risks = []
            recommendations = []
            trends = self._calculate_electricity_trends(data)
            
            return {
                'category': 'electricity',
                'raw_data': data,
                'facts': facts,
                'risks': risks,
                'recommendations': recommendations,
                'trends': trends,
                'data_points_count': len(data)
            }
            
        except Exception as e:
            logger.error(f"Error assessing electricity consumption: {e}")
            raise

    def assess_water_consumption(
        self,
        location_filter: Optional[str] = None,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Assess water consumption data.
        
        Returns:
            Dictionary containing water assessment data
        """
        try:
            # FIXED Query - Using Site relationships instead of facility_id
            query = """
            MATCH (s:Site)-[:HAS_WATER_CONSUMPTION]->(w:WaterConsumption)
            WHERE ($location IS NULL OR s.id CONTAINS $location OR s.name CONTAINS $location)
            AND ($start_date IS NULL OR w.date >= date($start_date))
            AND ($end_date IS NULL OR w.date <= date($end_date))
            RETURN s.id as location, s.name as site_name, w.date as date, w.consumption_gallons as consumption,
                   w.cost_usd as cost, 
                   COALESCE(w.source_type, 'Unknown') as source_type, 
                   COALESCE(w.quality_rating, 'Unknown') as efficiency
            ORDER BY w.date DESC
            """
            
            records = self.neo4j_client.execute_query(
                query,
                parameters={
                    "location": location_filter,
                    "start_date": start_date,
                    "end_date": end_date
                }
            )
            
            if not records:
                return {'error': 'No water data found'}
            
            # Process data
            data = [dict(record) for record in records]
            
            # Calculate metrics
            facts = self._calculate_water_facts(data)
            # Risks and recommendations come from Neo4j (generated by Risk Assessment Agent)
            risks = []
            recommendations = []
            trends = self._calculate_water_trends(data)
            
            return {
                'category': 'water',
                'raw_data': data,
                'facts': facts,
                'risks': risks,
                'recommendations': recommendations,
                'trends': trends,
                'data_points_count': len(data)
            }
            
        except Exception as e:
            logger.error(f"Error assessing water consumption: {e}")
            raise

    def assess_waste_generation(
        self,
        location_filter: Optional[str] = None,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Assess waste generation data.
        
        Returns:
            Dictionary containing waste assessment data
        """
        try:
            # FIXED Query - Using Site relationships instead of location property and fixed date comparison
            query = """
            MATCH (s:Site)-[:HAS_WASTE_GENERATION]->(w:WasteGeneration)
            WHERE ($location IS NULL OR s.id CONTAINS $location OR s.name CONTAINS $location)
            AND ($start_date IS NULL OR w.date >= date($start_date))
            AND ($end_date IS NULL OR w.date <= date($end_date))
            RETURN s.id as location, s.name as site_name, w.date as date, w.amount_pounds as amount,
                   w.disposal_cost_usd as cost, w.waste_type as waste_type, w.disposal_method as disposal_method,
                   0 as recycled
            ORDER BY w.date DESC
            """
            
            records = self.neo4j_client.execute_query(
                query,
                parameters={
                    "location": location_filter,
                    "start_date": start_date,
                    "end_date": end_date
                }
            )
            
            if not records:
                return {'error': 'No waste data found'}
            
            # Process data
            data = [dict(record) for record in records]
            
            # Calculate metrics
            facts = self._calculate_waste_facts(data)
            # Risks and recommendations come from Neo4j (generated by Risk Assessment Agent)
            risks = []
            recommendations = []
            trends = self._calculate_waste_trends(data)
            
            return {
                'category': 'waste',
                'raw_data': data,
                'facts': facts,
                'risks': risks,
                'recommendations': recommendations,
                'trends': trends,
                'data_points_count': len(data)
            }
            
        except Exception as e:
            logger.error(f"Error assessing waste generation: {e}")
            raise

    def get_llm_context_data(
        self,
        location_filter: Optional[str] = None,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None
    ) -> str:
        """
        Prepare environmental data in a format suitable for LLM context.
        
        Returns:
            String containing formatted environmental data for LLM
        """
        try:
            assessment = self.get_comprehensive_assessment(
                location_filter, start_date, end_date
            )
            
            context_parts = []
            context_parts.append("=== ENVIRONMENTAL ASSESSMENT DATA ===\n")
            
            # Add filters info
            if assessment['filters']['location']:
                context_parts.append(f"Location Filter: {assessment['filters']['location']}")
            if assessment['filters']['start_date'] or assessment['filters']['end_date']:
                context_parts.append(f"Date Range: {assessment['filters']['start_date']} to {assessment['filters']['end_date']}")
            
            # Add electricity data
            if 'electricity' in assessment and 'error' not in assessment['electricity']:
                elec = assessment['electricity']
                context_parts.append("\n--- ELECTRICITY CONSUMPTION ---")
                context_parts.append(f"Total Consumption: {elec['facts'].get('total_consumption', 0):,.0f} kWh")
                context_parts.append(f"Average Monthly: {elec['facts'].get('average_consumption', 0):,.0f} kWh")
                context_parts.append(f"Total Cost: ${elec['facts'].get('total_cost', 0):,.2f}")
                context_parts.append(f"Average Efficiency: {elec['facts'].get('average_efficiency', 0):.2f}")
                
            # Add water data
            if 'water' in assessment and 'error' not in assessment['water']:
                water = assessment['water']
                context_parts.append("\n--- WATER CONSUMPTION ---")
                context_parts.append(f"Total Consumption: {water['facts'].get('total_consumption', 0):,.0f} gallons")
                context_parts.append(f"Average Monthly: {water['facts'].get('average_consumption', 0):,.0f} gallons")
                context_parts.append(f"Total Cost: ${water['facts'].get('total_cost', 0):,.2f}")
                context_parts.append(f"Average Efficiency: {water['facts'].get('average_efficiency', 0):.2f}")
                
            # Add waste data
            if 'waste' in assessment and 'error' not in assessment['waste']:
                waste = assessment['waste']
                context_parts.append("\n--- WASTE GENERATION ---")
                context_parts.append(f"Total Generated: {waste['facts'].get('total_generated', 0):,.0f} lbs")
                context_parts.append(f"Total Recycled: {waste['facts'].get('total_recycled', 0):,.0f} lbs")
                context_parts.append(f"Recycling Rate: {waste['facts'].get('recycling_rate', 0):.1%}")
                context_parts.append(f"Total Cost: ${waste['facts'].get('total_cost', 0):,.2f}")
            
            # Add overall metrics
            if 'overall_metrics' in assessment:
                overall = assessment['overall_metrics']
                context_parts.append("\n--- OVERALL METRICS ---")
                context_parts.append(f"Total Environmental Cost: ${overall.get('total_cost', 0):,.2f}")
                context_parts.append(f"Overall Efficiency: {overall.get('overall_efficiency', 0):.2f}")
            
            return "\n".join(context_parts)
            
        except Exception as e:
            logger.error(f"Error preparing LLM context data: {e}")
            return f"Error preparing environmental data: {str(e)}"

    def _calculate_electricity_facts(self, data: List[Dict]) -> Dict[str, Any]:
        """Calculate electricity consumption facts."""
        if not data:
            return {}
        
        consumptions = [d['consumption'] for d in data if d['consumption']]
        costs = [d['cost'] for d in data if d['cost']]
        efficiencies = [d['efficiency'] for d in data if d['efficiency']]
        
        facts = {
            'total_consumption': sum(consumptions),
            'average_consumption': mean(consumptions) if consumptions else 0,
            'max_consumption': max(consumptions) if consumptions else 0,
            'min_consumption': min(consumptions) if consumptions else 0,
            'total_cost': sum(costs),
            'average_cost': mean(costs) if costs else 0,
            'average_efficiency': mean(efficiencies) if efficiencies else 0,
            'data_points': len(data),
            'date_range': {
                'start': str(min(d['date'] for d in data)),
                'end': str(max(d['date'] for d in data))
            }
        }
        
        if len(consumptions) > 1:
            facts['consumption_std_dev'] = stdev(consumptions)
            facts['cost_per_kwh'] = sum(costs) / sum(consumptions) if sum(consumptions) > 0 else 0
        
        return facts

    def _calculate_water_facts(self, data: List[Dict]) -> Dict[str, Any]:
        """Calculate water consumption facts."""
        if not data:
            return {}
        
        consumptions = [d['consumption'] for d in data if d['consumption']]
        costs = [d['cost'] for d in data if d['cost']]
        # For water, efficiency comes from quality_rating - convert to numeric if needed
        efficiencies = []
        for d in data:
            if d['efficiency']:
                # Convert quality rating to numeric (A=1.0, B=0.8, C=0.6, etc.)
                rating = d['efficiency']
                if rating == 'A':
                    efficiencies.append(1.0)
                elif rating == 'B':
                    efficiencies.append(0.8)
                elif rating == 'C':
                    efficiencies.append(0.6)
                elif rating == 'D':
                    efficiencies.append(0.4)
                else:
                    efficiencies.append(0.5)  # default
        
        facts = {
            'total_consumption': sum(consumptions),
            'average_consumption': mean(consumptions) if consumptions else 0,
            'max_consumption': max(consumptions) if consumptions else 0,
            'min_consumption': min(consumptions) if consumptions else 0,
            'total_cost': sum(costs),
            'average_cost': mean(costs) if costs else 0,
            'average_efficiency': mean(efficiencies) if efficiencies else 0,
            'data_points': len(data),
            'date_range': {
                'start': str(min(d['date'] for d in data)),
                'end': str(max(d['date'] for d in data))
            }
        }
        
        if len(consumptions) > 1:
            facts['consumption_std_dev'] = stdev(consumptions)
            facts['cost_per_gallon'] = sum(costs) / sum(consumptions) if sum(consumptions) > 0 else 0
        
        return facts

    def _calculate_waste_facts(self, data: List[Dict]) -> Dict[str, Any]:
        """Calculate waste generation facts."""
        if not data:
            return {}
        
        amounts = [d['amount'] for d in data if d['amount']]
        costs = [d['cost'] for d in data if d['cost']]
        recycled = [d['recycled'] or 0 for d in data]
        
        total_generated = sum(amounts)
        total_recycled = sum(recycled)
        
        facts = {
            'total_generated': total_generated,
            'total_recycled': total_recycled,
            'recycling_rate': total_recycled / total_generated if total_generated > 0 else 0,
            'average_generated': mean(amounts) if amounts else 0,
            'max_generated': max(amounts) if amounts else 0,
            'min_generated': min(amounts) if amounts else 0,
            'total_cost': sum(costs),
            'average_cost': mean(costs) if costs else 0,
            'data_points': len(data),
            'date_range': {
                'start': str(min(d['date'] for d in data)),
                'end': str(max(d['date'] for d in data))
            }
        }
        
        if len(amounts) > 1:
            facts['generation_std_dev'] = stdev(amounts)
            facts['cost_per_lb'] = sum(costs) / sum(amounts) if sum(amounts) > 0 else 0
        
        # Waste type breakdown
        waste_types = {}
        for d in data:
            waste_type = d.get('waste_type', 'unknown')
            waste_types[waste_type] = waste_types.get(waste_type, 0) + d['amount']
        
        facts['waste_types'] = waste_types
        
        return facts

    def _calculate_electricity_trends(self, data: List[Dict]) -> Dict[str, Any]:
        """Calculate electricity consumption trends."""
        if len(data) < 2:
            return {'trend': 'insufficient_data'}
        
        # Sort by date
        sorted_data = sorted(data, key=lambda x: x['date'])
        
        # Calculate month-over-month changes
        consumptions = [d['consumption'] for d in sorted_data if d['consumption']]
        costs = [d['cost'] for d in sorted_data if d['cost']]
        
        if len(consumptions) >= 2:
            consumption_change = ((consumptions[-1] - consumptions[0]) / consumptions[0]) * 100
            cost_change = ((costs[-1] - costs[0]) / costs[0]) * 100 if costs else 0
            
            return {
                'consumption_trend': 'increasing' if consumption_change > 5 else 'decreasing' if consumption_change < -5 else 'stable',
                'consumption_change_percent': consumption_change,
                'cost_trend': 'increasing' if cost_change > 5 else 'decreasing' if cost_change < -5 else 'stable',
                'cost_change_percent': cost_change,
                'data_points': len(consumptions)
            }
        
        return {'trend': 'insufficient_data'}

    def _calculate_water_trends(self, data: List[Dict]) -> Dict[str, Any]:
        """Calculate water consumption trends."""
        if len(data) < 2:
            return {'trend': 'insufficient_data'}
        
        sorted_data = sorted(data, key=lambda x: x['date'])
        consumptions = [d['consumption'] for d in sorted_data if d['consumption']]
        
        if len(consumptions) >= 2:
            change = ((consumptions[-1] - consumptions[0]) / consumptions[0]) * 100
            
            return {
                'consumption_trend': 'increasing' if change > 5 else 'decreasing' if change < -5 else 'stable',
                'consumption_change_percent': change,
                'data_points': len(consumptions)
            }
        
        return {'trend': 'insufficient_data'}

    def _calculate_waste_trends(self, data: List[Dict]) -> Dict[str, Any]:
        """Calculate waste generation trends."""
        if len(data) < 2:
            return {'trend': 'insufficient_data'}
        
        sorted_data = sorted(data, key=lambda x: x['date'])
        amounts = [d['amount'] for d in sorted_data if d['amount']]
        recycled = [d.get('recycled', 0) for d in sorted_data]
        
        if len(amounts) >= 2:
            generation_change = ((amounts[-1] - amounts[0]) / amounts[0]) * 100
            
            # Calculate recycling rate trend
            old_rate = recycled[0] / amounts[0] if amounts[0] > 0 else 0
            new_rate = recycled[-1] / amounts[-1] if amounts[-1] > 0 else 0
            recycling_change = ((new_rate - old_rate) / old_rate) * 100 if old_rate > 0 else 0
            
            return {
                'generation_trend': 'increasing' if generation_change > 5 else 'decreasing' if generation_change < -5 else 'stable',
                'generation_change_percent': generation_change,
                'recycling_trend': 'improving' if recycling_change > 5 else 'declining' if recycling_change < -5 else 'stable',
                'recycling_change_percent': recycling_change,
                'data_points': len(amounts)
            }
        
        return {'trend': 'insufficient_data'}

    def _calculate_overall_metrics(self, electricity_data: Dict, water_data: Dict, waste_data: Dict) -> Dict[str, Any]:
        """Calculate overall environmental metrics."""
        total_cost = 0
        
        # Aggregate costs
        for category_data in [electricity_data, water_data, waste_data]:
            if 'facts' in category_data:
                total_cost += category_data['facts'].get('total_cost', 0)
        
        # Calculate efficiency metrics
        efficiency_scores = []
        for category_data in [electricity_data, water_data, waste_data]:
            if 'facts' in category_data:
                if 'average_efficiency' in category_data['facts']:
                    efficiency_scores.append(category_data['facts']['average_efficiency'])
        
        overall_efficiency = mean(efficiency_scores) if efficiency_scores else 0
        
        return {
            'total_cost': total_cost,
            'overall_efficiency': round(overall_efficiency, 2)
        }
